<!DOCTYPE html>
<html lang="fr">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Shonen QCM Forge - Le Tycoon du QCM Médical</title>

   <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
   <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

   <style>
       /* --- Root Variables --- */
       :root {
           --primary: #6a4c93; --secondary: #4CAF50; --accent: #ff9a3c;
           --dark: #1a1423; --light: #f8f9fa; --combo-bar-bg: #e0e0e0;
           --combo-bar-fill: linear-gradient(90deg, var(--accent), #e74c3c);
           --admin-color: #dc3545; --market-up: #2ecc71; --market-down: #e74c3c;
           --buy-color: #3498db; --sell-color: #e67e22; --chart-line: var(--primary);
           --chart-fill: rgba(106, 76, 147, 0.1); --funding-color: #1abc9c;
           --code-color: #3498db; --ai-color: #9b59b6; --server-color: #34495e;
           --research-color: #16a085;
           --worker-cell-bg: rgba(76, 175, 80, 0.1); --module-cell-bg: rgba(106, 76, 147, 0.1);
           --server-cell-bg: rgba(52, 73, 94, 0.1); --ai-cell-bg: rgba(155, 89, 182, 0.1);
           --marketing-cell-bg: rgba(241, 196, 15, 0.1);
           --event-positive-bg: rgba(46, 204, 113, 0.15); --event-positive-border: rgba(46, 204, 113, 0.5);
           --event-negative-bg: rgba(231, 76, 60, 0.15); --event-negative-border: rgba(231, 76, 60, 0.5);
       }
       /* --- Global Styles --- */
       * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
       body { background-color: #f5f5f5; color: var(--dark); overflow-x: hidden; background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIG9wYWNpdHk9IjAuMDUiPjxwYXRoIGQ9Ik0wIDUwIEwxMDAgNTAgTSA1MCAwIEwgNTAgMTAwIiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMSIvPjwvc3ZnPg=='); min-height: 100vh; }
       .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
       /* --- Header Styles --- */
       header { display: flex; justify-content: space-between; align-items: center; padding: 15px 0; border-bottom: 2px solid var(--secondary); margin-bottom: 20px; flex-wrap: wrap; gap: 15px; }
       .logo { display: flex; align-items: center; gap: 10px; }
       .logo i { color: var(--primary); font-size: 2rem; }
       .logo h1 { font-size: 1.6rem; color: var(--primary); text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
       .stats { display: flex; gap: 15px; flex-wrap: wrap; }
       .stat-box { background-color: white; padding: 8px 12px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 8px; font-size: 0.9rem; }
       .stat-box i.fa-question-circle { color: var(--accent); } .stat-box i.fa-bolt { color: var(--code-color); } .stat-box i.fa-hand-pointer { color: var(--secondary); }
       .crit-stats { font-size: 0.75rem; color: #777; margin-left: 5px; }
       .save-load-buttons { display: flex; gap: 10px; margin-top: 10px; flex-basis: 100%; justify-content: flex-end; align-items: center; }
       .save-load-buttons button { background-color: var(--secondary); color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; transition: background-color 0.2s; }
       .save-load-buttons button:hover { background-color: var(--primary); }
       #mute-btn { background-color: #ccc; margin-left: 10px; width: 40px; height: 34px; padding: 0; display: flex; align-items: center; justify-content: center; }
       #mute-btn:hover { background-color: #bbb; } #mute-btn i { font-size: 1rem; }
       /* Event Display Styles */
       #event-display { padding: 10px 15px; margin: 15px auto 0 auto; border-radius: 8px; font-size: 0.9rem; text-align: center; max-width: 600px; border: 1px solid transparent; display: none; transition: all 0.3s ease-in-out; }
       #event-display.positive { background-color: var(--event-positive-bg); border-color: var(--event-positive-border); color: #1e8449; }
       #event-display.negative { background-color: var(--event-negative-bg); border-color: var(--event-negative-border); color: #b03a2e; }
       #event-display strong { display: block; margin-bottom: 3px; }
       /* --- Main Game Area Styles --- */
       .main-game { display: flex; gap: 30px; margin-top: 20px; }
       .click-area { flex: 1; display: flex; flex-direction: column; align-items: center; background-color: white; padding: 20px 30px 30px 30px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); position: relative; overflow: hidden; text-align: center; }
       .click-area::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 10px; background: linear-gradient(90deg, var(--primary), var(--accent), var(--secondary)); }
       .click-area h2 { color: var(--primary); margin-bottom: 10px; }
       .bone-btn { background: none; border: none; cursor: pointer; position: relative; margin: 15px 0; transition: transform 0.1s; }
       .bone-btn:active { transform: scale(0.95); }
       .clickable-image { width: 180px; height: 180px; object-fit: contain; filter: drop-shadow(0 5px 10px rgba(0,0,0,0.2)); transition: opacity 0.3s ease-in-out; }
       #combo-area { width: 80%; margin-top: 15px; text-align: center; }
       #combo-bar-container { height: 10px; background-color: var(--combo-bar-bg); border-radius: 5px; overflow: hidden; margin-bottom: 5px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
       #combo-bar { height: 100%; width: 0%; background: var(--combo-bar-fill); border-radius: 5px; transition: width 0.1s linear; }
       #combo-text { font-size: 0.8rem; color: #555; font-weight: bold; height: 1.2em; }
       #flavor-text-area { margin-top: 10px; font-style: italic; color: #555; font-size: 0.85rem; min-height: 2.5em; display: flex; justify-content: center; align-items: center; padding: 5px 10px; background-color: rgba(0,0,0,0.02); border-radius: 4px; max-width: 80%; transition: opacity 0.5s ease-in-out; }
       #flavor-text-area.fade-out { opacity: 0; } #flavor-text-area.fade-in { opacity: 1; }
       /* --- Upgrades Section Styles --- */
       .upgrades { width: 350px; background-color: white; border-radius: 15px; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); max-height: calc(100vh - 220px); overflow-y: auto; }
       .upgrades h2 { color: var(--primary); margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 8px; }
       .upgrades h3 { color: var(--primary); margin-top: 20px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px dashed #eee; font-size: 1rem; text-transform: capitalize; }
       .upgrade-item { display: flex; align-items: center; padding: 12px 10px; border-radius: 8px; margin-bottom: 10px; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; cursor: pointer; border: 1px solid #eee; position: relative; border-left: 4px solid #ccc; }
       .upgrade-item:hover { background-color: #fafafa; border-color: #ddd; }
       .upgrade-item.bought { background-color: rgba(106, 76, 147, 0.05); border-color: rgba(106, 76, 147, 0.2); opacity: 0.7; cursor: default; border-left-color: rgba(106, 76, 147, 0.4); }
       .upgrade-item.can-afford { border-left: 4px solid var(--accent); box-shadow: 0 0 8px rgba(255, 154, 60, 0.3); animation: pulse-afford 1.5s infinite ease-in-out; }
       .upgrade-item.can-afford:hover { background-color: #fff8f0; animation-play-state: paused; }
       .upgrade-item.disabled { opacity: 0.5; pointer-events: none; background-color: #f9f9f9; border-left: 4px solid #eee; }
       @keyframes pulse-afford { 0% { box-shadow: 0 0 8px rgba(255, 154, 60, 0.3); } 50% { box-shadow: 0 0 12px rgba(255, 154, 60, 0.5); } 100% { box-shadow: 0 0 8px rgba(255, 154, 60, 0.3); } }
       .upgrade-icon { width: 45px; height: 45px; background-color: #f0f0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; color: var(--primary); font-size: 1.1rem; flex-shrink: 0; }
       .upgrade-info { flex: 1; }
       .upgrade-name { font-weight: 600; color: var(--dark); font-size: 0.95rem; }
       .upgrade-desc { font-size: 0.75rem; color: #666; margin-top: 3px; }
       .upgrade-cost { font-weight: 700; color: var(--primary); white-space: nowrap; margin-left: 10px; font-size: 0.9rem; }
       .upgrade-cost span.reduced { text-decoration: line-through; font-size: 0.75rem; opacity: 0.7; margin-right: 5px; }
       .upgrade-cost::after { content: " Q"; font-size: 0.8em; opacity: 0.8; }
       /* --- Milestones Section Styles --- */
       .milestones { margin-top: 30px; background-color: white; padding: 20px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
       .milestones h2 { color: var(--primary); margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
       .milestone-container { display: flex; gap: 15px; flex-wrap: wrap; }
       .milestone { background-color: #f0f0f0; padding: 10px 15px; border-radius: 8px; font-size: 0.85rem; position: relative; overflow: hidden; flex: 1; min-width: 180px; }
       .milestone.achieved { background-color: rgba(106, 76, 147, 0.1); }
       .milestone.achieved::after { content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 8px; right: 12px; color: var(--primary); font-size: 0.9rem; }
       .milestone-progress { margin-top: 5px; background-color: #ddd; height: 5px; border-radius: 3px; overflow: hidden; }
       .milestone-bar { height: 100%; background: linear-gradient(90deg, var(--primary), var(--accent)); width: 0; transition: width 0.5s ease-in-out; }
       /* --- Factory View / Development Progress Styles --- */
       .factory-view { margin-top: 30px; background-color: white; padding: 20px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); position: relative; min-height: 200px; overflow: hidden; }
       .factory-title { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; color: var(--primary); }
       .factory-title h2 { display: flex; align-items: center; gap: 8px; }
       .factory-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 8px; }
       .factory-cell { height: 40px; background-color: #f9f9f9; border-radius: 5px; display: flex; align-items: center; justify-content: center; color: #999; font-size: 1rem; transition: all 0.3s; border: 1px solid #eee; }
       .factory-cell.filled { border-color: transparent; box-shadow: inset 0 0 3px rgba(0,0,0,0.1); }
       .factory-cell.stagiaire { background-color: var(--worker-cell-bg); color: var(--secondary); }
       .factory-cell.module { background-color: var(--module-cell-bg); color: var(--primary); }
       .factory-cell.serveur, .factory-cell.serveur_lunaire, .factory-cell.serveur_mars { background-color: var(--server-cell-bg); color: var(--server-color); }
       .factory-cell.ia_neuronal { background-color: var(--ai-cell-bg); color: var(--ai-color); }
       .factory-cell.mineur_buzz { background-color: var(--marketing-cell-bg); color: var(--crypto-color); }
       /* --- Market Styles --- */
       .bone-market { margin-top: 30px; background-color: white; padding: 20px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
       .bone-market h2 { color: var(--primary); margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
       .market-info { display: flex; justify-content: space-around; align-items: center; background-color: #f8f8f8; padding: 15px; border-radius: 8px; margin-bottom: 15px; flex-wrap: wrap; gap: 10px; }
       .market-stat { text-align: center; } .market-stat strong { display: block; font-size: 1.1rem; margin-bottom: 5px; } .market-stat span { font-size: 0.85rem; color: #555; }
       .market-trend { font-weight: bold; } .market-trend.up { color: var(--market-up); } .market-trend.down { color: var(--market-down); }
       .market-chart-container { position: relative; height: 150px; width: 100%; margin-bottom: 15px; background-color: #fdfdfd; border-radius: 8px; padding: 10px; border: 1px solid #eee; }
       .market-tendencies { display: flex; justify-content: space-around; font-size: 0.8rem; color: #555; margin-bottom: 15px; padding: 10px 0; border-top: 1px dashed #eee; border-bottom: 1px dashed #eee; flex-wrap: wrap; gap: 10px; }
       .tendency-value { font-weight: bold; } .tendency-value.up { color: var(--market-up); } .tendency-value.down { color: var(--market-down); }
       .market-actions { display: flex; justify-content: space-around; gap: 20px; flex-wrap: wrap; }
       .market-action-group { display: flex; flex-direction: column; align-items: center; gap: 10px; flex: 1; min-width: 180px; }
       .market-action-group h4 { color: var(--secondary); margin-bottom: 5px; }
       .market-amount-buttons { display: flex; gap: 5px; flex-wrap: wrap; justify-content: center; }
       .market-amount-buttons button { background-color: #e0e0e0; color: var(--dark); border: 1px solid #ccc; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; transition: background-color 0.2s, border-color 0.2s; min-width: 40px; }
       .market-amount-buttons button:hover { background-color: #d0d0d0; border-color: #bbb; }
       .market-amount-buttons button.buy-btn { background-color: var(--buy-color); color: white; border-color: transparent; } .market-amount-buttons button.buy-btn:hover { background-color: #2980b9; }
       .market-amount-buttons button.sell-btn { background-color: var(--sell-color); color: white; border-color: transparent; } .market-amount-buttons button.sell-btn:hover { background-color: #d35400; }
       .market-amount-buttons button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.6; }
       #market-feedback { margin-top: 15px; text-align: center; font-size: 0.8rem; color: #555; height: 1.2em; font-style: italic; }
       /* --- Funding Store Styles --- */
       .funding-store { margin-top: 30px; background-color: white; padding: 20px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
       .funding-store h2 { color: var(--primary); margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
       .funding-items-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
       .funding-item { background-color: #f8f8f8; border: 1px solid #eee; border-radius: 8px; padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; }
       .funding-icon { font-size: 2rem; color: var(--funding-color); margin-bottom: 10px; }
       .funding-info strong { display: block; font-size: 1rem; color: var(--dark); margin-bottom: 5px; }
       .funding-info span { font-size: 0.8rem; color: #666; margin-bottom: 10px; display: block; }
       .collect-btn { background-color: var(--funding-color); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 0.9rem; transition: background-color 0.2s; margin-top: auto; }
       .collect-btn:hover { background-color: #16a085; }
       /* --- Notification Styles --- */
       .notification { position: fixed; bottom: 20px; right: 20px; background-color: var(--primary); color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transform: translateY(120%); transition: transform 0.4s ease-out; z-index: 1000; display: flex; align-items: center; gap: 10px; max-width: 350px; }
       .notification.show { transform: translateY(0); }
       .notification i.fa-question-circle { color: var(--accent); }
       /* --- Floating Text/Particle Effects --- */
       .floating-text { position: absolute; color: var(--primary); font-weight: bold; pointer-events: none; animation: float-up 1s forwards ease-out; text-shadow: 0 1px 3px rgba(0,0,0,0.2); z-index: 999; font-size: 1.1rem; }
       .floating-text.crit { color: var(--accent); font-size: 1.4rem; font-weight: 900; animation: float-up-crit 1s forwards ease-out; }
       .floating-text.bonus { color: var(--ai-color); font-size: 1.3rem; font-weight: bold; animation: float-up-bonus 1.2s forwards ease-out; }
       @keyframes float-up-crit { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-80px) scale(1.2); } }
       @keyframes float-up { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-60px); } }
       @keyframes float-up-bonus { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-70px) scale(1.1); } }
       .floating-particle { position: absolute; width: 20px; height: 20px; color: var(--accent); font-size: 20px; pointer-events: none; animation: particle-float 1.5s forwards ease-out; z-index: 998; opacity: 0.8; }
       @keyframes particle-float { 0% { opacity: 0.8; transform: translate(0, 0) rotate(0deg) scale(1); } 100% { opacity: 0; transform: translate(var(--tx, 50px), var(--ty, -100px)) rotate(var(--rot, 360deg)) scale(0.5); } }
       /* --- Auto Producer Display Styles --- */
       .auto-producers { display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
       .auto-producer { background-color: #f8f8f8; padding: 8px 12px; border-radius: 8px; display: flex; align-items: center; gap: 10px; font-size: 0.85rem; flex: 1; min-width: 130px; }
       .auto-producer i { color: var(--accent); font-size: 1.1rem; }
       .auto-producer i.fa-user-graduate, .auto-producer i.fa-user-ninja, .auto-producer i.fa-user-tie { color: var(--secondary); }
       .auto-producer i.fa-cogs, .auto-producer i.fa-microchip { color: var(--primary); }
       .auto-producer i.fa-server, .auto-producer i.fa-database, .auto-producer i.fa-network-wired, .auto-producer i.fa-cloud, .auto-producer i.fa-globe, .auto-producer i.fa-wifi { color: var(--server-color); }
       .auto-producer i.fa-brain, .auto-producer i.fa-dna, .auto-producer i.fa-comments, .auto-producer i.fa-book-medical, .auto-producer i.fa-check-double, .auto-producer i.fa-dice { color: var(--ai-color); }
       .auto-producer i.fa-bullhorn, .auto-producer i.fa-rocket, .auto-producer i.fa-robot, .auto-producer i.fa-video, .auto-producer i.fa-search { color: var(--crypto-color); }
       /* --- Tooltip Styles --- */
       #tooltip { position: fixed; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 10px 15px; border-radius: 6px; font-size: 0.8rem; white-space: normal; max-width: 250px; z-index: 1001; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
       #tooltip.visible { opacity: 1; } #tooltip strong { color: var(--accent); display: block; margin-bottom: 5px; } #tooltip hr { border: none; border-top: 1px solid #555; margin: 5px 0; }
       #tooltip .cost, #tooltip .effect { margin-top: 5px; } #tooltip .cost span, #tooltip .effect span { color: #ddd; }
       #tooltip .cost .original-cost { text-decoration: line-through; opacity: 0.7; margin-left: 5px; font-size: 0.9em; }
       #tooltip .cost span::after { content: " Q"; font-size: 0.9em; opacity: 0.8; } #tooltip .cost .original-cost::after { content: " Q"; font-size: 0.9em; opacity: 0.8; }
       /* --- Responsive Adjustments --- */
       @media (max-width: 900px) { .main-game { flex-direction: column; } .upgrades { width: 100%; max-height: 40vh; } .stats { gap: 10px; } header { justify-content: center; } .save-load-buttons { justify-content: center; } .auto-producers { justify-content: center; } }
       @media (max-width: 600px) { .logo h1 { font-size: 1.4rem; } .stat-box { font-size: 0.8rem; padding: 6px 10px; } .clickable-image { width: 150px; height: 150px; } .upgrades { padding: 15px; } .upgrade-item { padding: 10px 8px; } .upgrade-icon { width: 40px; height: 40px; margin-right: 10px; font-size: 1rem; } .upgrade-name { font-size: 0.9rem; } .upgrade-desc { font-size: 0.7rem; } .upgrade-cost { font-size: 0.85rem; } #flavor-text-area { max-width: 90%; font-size: 0.8rem; } #combo-area { width: 90%; } .market-info { flex-direction: column; gap: 10px; } .market-actions { flex-direction: column; gap: 15px; } .market-tendencies { flex-direction: column; align-items: center; gap: 5px;} .funding-items-container { grid-template-columns: 1fr; } }
       /* --- Custom Scrollbar --- */
       ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; } ::-webkit-scrollbar-thumb { background: var(--secondary); border-radius: 10px; } ::-webkit-scrollbar-thumb:hover { background: var(--primary); }
   </style>
</head>
<body>
   <div class="container">
       <header>
           <div class="logo"> <i class="fas fa-brain"></i> <h1>Shonen QCM Forge</h1> </div>
           <div class="stats">
               <div class="stat-box"> <i class="fas fa-question-circle"></i> <span id="bones">0</span> Questions </div>
               <div class="stat-box" title="Questions par Seconde"> <i class="fas fa-bolt"></i> <span id="bps">0</span> QPS </div>
               <div class="stat-box" title="Questions par Clic"> <i class="fas fa-hand-pointer"></i> <span id="bpc">1</span> QPC <span id="crit-stats-display" class="crit-stats" title="Chance Critique / Multiplicateur">(0% / x1.5)</span> </div>
           </div>
           <div class="save-load-buttons">
                <button id="manual-save-btn" title="Sauvegarde Manuelle"><i class="fas fa-save"></i> Sauver</button>
                <button id="export-save-btn" title="Exporter Sauvegarde"><i class="fas fa-file-export"></i> Exporter</button>
                <button id="import-save-btn" title="Importer Sauvegarde"><i class="fas fa-file-import"></i> Importer</button>
               
                <button id="admin-reset-btn" title="Admin: Réinitialiser Améliorations"><i class="fas fa-undo"></i> Reset Upg.</button>
                <button id="mute-btn" title="Activer/Désactiver Son"><i class="fas fa-volume-up"></i></button>
            </div>
       </header>
       <div id="event-display"></div>
       <div class="main-game">
           <div class="click-area">
               <h2>Cliquez pour générer des questions !</h2>
               <button class="bone-btn" id="bone-btn">
                   <img src="" alt="Générer Question" class="clickable-image">
               </button>
               <p>Cliquez ou tapez pour générer des QCM pour Shonen</p>
               <div id="combo-area"> <div id="combo-bar-container"><div id="combo-bar"></div></div> <div id="combo-text"></div> </div>
               <div id="flavor-text-area">Prêt à coder ?</div> </div>
           <div class="upgrades"> <h2><i class="fas fa-arrow-up"></i> Améliorations</h2> <div id="upgrades-container"></div> </div>
       </div>
       <div class="auto-producers">
           <div class="auto-producer"> <i class="fas fa-user-graduate"></i> <span id="workers-count">0</span> Stagiaires </div>
           <div class="auto-producer"> <i class="fas fa-cogs"></i> <span id="factories-count">0</span> Modules </div>
           <div class="auto-producer"> <i class="fas fa-server"></i> <span id="orbital-stations-count">0</span> Serveurs </div>
           <div class="auto-producer"> <i class="fas fa-database"></i> <span id="lunar-bases-count">0</span> BDD Scalables </div>
           <div class="auto-producer"> <i class="fas fa-network-wired"></i> <span id="mars-colonies-count">0</span> Clusters Cloud </div>
           <div class="auto-producer"> <i class="fas fa-brain"></i> <span id="cloning-vats-count">0</span> IA Neuronales </div>
           <div class="auto-producer"> <i class="fas fa-bullhorn"></i> <span id="bonecoin-miners-count">0</span> Bots Marketing </div>
       </div>
       <div class="milestones"> <h2><i class="fas fa-trophy"></i> Objectifs</h2> <div class="milestone-container" id="milestones-container"></div> </div>
       <div class="bone-market" id="bone-market-section" style="display: none;">
           <h2><i class="fas fa-chart-line"></i> Marché API</h2>
           <div class="market-info">
               <div class="market-stat"> <strong id="bone-price">1.00</strong> <span>Prix Actuel (€/Q)</span> </div>
               <div class="market-stat"> <strong id="market-trend" class="market-trend">Stable</strong> <span>Tendance Marché</span> </div>
               <div class="market-stat"> <strong>€<span id="cash-amount">0</span></strong> <span>Trésorerie</span> </div>
           </div>
           <div class="market-chart-container"> <canvas id="price-chart"></canvas> </div>
           <div class="market-tendencies" id="market-tendencies">
               <span>1m: <span class="tendency-value" id="tendency-1m">N/A</span></span>
               <span>5m: <span class="tendency-value" id="tendency-5m">N/A</span></span>
               <span>10m: <span class="tendency-value" id="tendency-10m">N/A</span></span>
           </div>
           <div class="market-actions" id="market-actions-area">
                <div class="market-action-group">
                    <h4>Acheter Questions (API Externe)</h4>
                    <div class="market-amount-buttons" id="market-buy-buttons"> </div>
                </div>
                <div class="market-action-group">
                    <h4>Vendre Questions (Licence API)</h4>
                    <div class="market-amount-buttons" id="market-sell-buttons"> </div>
                </div>
           </div>
           <div id="market-feedback"></div>
       </div>
       <div class="factory-view">
           <div class="factory-title"> <h2><i class="fas fa-tasks"></i> Progression Développement</h2> <span id="factory-level">Niveau 0</span> </div>
           <div class="factory-grid" id="factory-grid"></div>
       </div>
       <div class="funding-store">
            <h2><i class="fas fa-euro-sign"></i> Recherche Financements</h2>
            <div class="funding-items-container" id="funding-items-container"></div>
       </div>
   </div> <div id="tooltip"></div>
   <div class="notification" id="notification"> <i class="fas fa-check-circle"></i> <span id="notification-text">Notification text</span> </div>

   <script>
       // --- Asset Definitions ---
       const clickableImageSources = { default: 'assets/code-v1.png', enhanced: 'assets/code-optimise.png', advanced: 'assets/ia-active.png', cosmic: 'assets/code-quantique.png' };
       const clickableImageTierOrder = ['default', 'enhanced', 'advanced', 'cosmic'];
       const producerIcons = { stagiaire: 'fas fa-user-graduate', module: 'fas fa-cogs', serveur: 'fas fa-server', serveur_lunaire: 'fas fa-database', serveur_mars: 'fas fa-network-wired', ia_neuronal: 'fas fa-brain', mineur_buzz: 'fas fa-bullhorn' };
       const randomEvents = [ { id: 'codeRush', name: 'Rush de Code !', description: 'Boost de productivité ! (+50% QPS)', duration: 60, effect: { tempMultiplierBPS: 1.5 }, notificationIcon: 'fas fa-coffee', weight: 5, isNegative: false }, { id: 'inspiration', name: 'Éclair de Génie !', description: 'Les idées fusent ! (x3 QPC)', duration: 30, effect: { tempMultiplierBPC: 3.0 }, notificationIcon: 'fas fa-lightbulb', weight: 4, isNegative: false }, { id: 'serverCrash', name: 'Crash Serveur Mineur !', description: 'Oups. Ralentissement de la génération. (-25% QPS)', duration: 90, effect: { tempMultiplierBPS: 0.75 }, notificationIcon: 'fas fa-fire-extinguisher', weight: 2, isNegative: true }, { id: 'apiDemand', name: 'Forte Demande API !', description: 'Le prix des questions monte ! (x1.5 Prix)', duration: 120, effect: { tempBonePriceMultiplier: 1.5 }, notificationIcon: 'fas fa-chart-line', weight: 1, isNegative: false } ];
       const MIN_TIME_BETWEEN_EVENTS = 90 * 1000; const EVENT_TRIGGER_CHANCE_PER_SECOND = 0.015;

       // --- Game State Object ---
       const gameState = {
           bones: 0, bonesPerClick: 1, totalClicks: 0, bonesPerSecond: 0, earnedTotal: 0,
           ownedUpgrades: [], unlockedCategories: ['basic', 'clicking'], achievements: {},
           factoryProgress: 0, factoryLevel: 0, lastSaveTime: Date.now(),
           critChance: 0, critMultiplier: 1.5, comboCount: 0, comboTimer: 0, comboDuration: 2000, maxCombo: 10, baseComboMultiplier: 0.1,
           globalMultiplierBPC: 1.0, globalMultiplierBPS: 1.0,
           marketUnlocked: false, cash: 0, bonePrice: 1.0, marketTrend: 0, marketVolatility: 0.05, marketTrendStrength: 0, marketStabilityBonus: 0,
           priceHistory: [], maxHistoryPoints: 120,
           producerCounts: { stagiaire: 0, module: 0, serveur: 0, serveur_lunaire: 0, serveur_mars: 0, ia_neuronal: 0, mineur_buzz: 0 },
           currentClickableImageTier: 'default', activeEventId: null, activeEventEndTime: 0,
           temporaryMultipliers: { BPS: 1.0, BPC: 1.0, bonePrice: 1.0 },
           lastEventTriggerTime: 0, isMuted: false,
       };

       // --- Global Variables ---
       let priceChartInstance = null; let flavorTextInterval; let marketFeedbackTimeout; let tooltipTimeout; let eventDisplayInterval = null;
       let audioCtx; let soundBuffers = {}; let soundsLoaded = false;

       // --- Number Formatting ---
       const numberSuffixes = ['', ' k', ' M', ' Md', ' T', ' Qa', ' Qi', ' Sx', ' Sp', ' Oc', ' No', ' Dc'];
       function formatNumber(num, decimals = 1) { if (num === undefined || num === null || isNaN(num)) return '0'; if (Math.abs(num) < 1000) return num.toFixed(0); const isNegative = num < 0; num = Math.abs(num); const exponent = Math.floor(Math.log10(num) / 3); if (exponent >= numberSuffixes.length) { return (isNegative ? '-' : '') + num.toExponential(2); } const suffix = numberSuffixes[exponent] || ''; let shortNum = num / Math.pow(1000, exponent); let dec = decimals; if (shortNum < 10) dec = 2; else if (shortNum < 100) dec = 1; else dec = 0; let formattedNum = shortNum.toFixed(dec); if (parseFloat(formattedNum) >= 1000 && exponent < numberSuffixes.length - 1) { const nextExponent = exponent + 1; const nextSuffix = numberSuffixes[nextExponent] || ''; const nextShortNum = num / Math.pow(1000, nextExponent); if (nextShortNum < 10) dec = 2; else if (nextShortNum < 100) dec = 1; else dec = 0; formattedNum = nextShortNum.toFixed(dec) + nextSuffix; } else { formattedNum += suffix; } return (isNegative ? '-' : '') + formattedNum; }
       function formatNumberPrecise(num) { if (num === undefined || num === null || isNaN(num)) return '0'; return Math.floor(num).toLocaleString('fr-FR'); }
       function formatTime(seconds) { if (seconds < 0) seconds = 0; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs < 10 ? '0' : ''}${secs}`; }

       // --- Data Definitions ---
       const upgrades = [ { id: 'algoV1', name: 'Algorithme d\'Ébauche V1', description: 'Génère des questions basiques... très basiques. (+1 QPC)', category: 'basic', cost: 50, unlockedAt: 0, effect: { addBPC: 1 }, icon: 'fas fa-pencil-alt' }, { id: 'compilateurOptimise', name: 'Compilateur Optimisé', description: 'Moins de bugs (en théorie), plus de questions ! (+2 QPC)', category: 'basic', cost: 200, unlockedAt: 100, effect: { addBPC: 2 }, icon: 'fas fa-bolt' }, { id: 'bddStructuree', name: 'Base de Données Structurée', description: 'Permet de stocker plus... de potentiel ? (+5 QPC)', category: 'basic', cost: 1000, unlockedAt: 500, effect: { addBPC: 5 }, icon: 'fas fa-database' }, { id: 'sourisErgo', name: 'Souris Ergonomique', description: 'Pour ces longues nuits de code... Ajoute 1% chance critique.', category: 'clicking', cost: 750, unlockedAt: 250, effect: { addCritChance: 0.01 }, icon: 'fas fa-computer-mouse' }, { id: 'cafeineIV', name: 'Caféine en Intra-Veineuse', description: 'Voir le code en couleurs ! Ajoute 2% chance critique.', category: 'clicking', cost: 5000, unlockedAt: 2000, effect: { addCritChance: 0.02 }, icon: 'fas fa-mug-hot' }, { id: 'debugIntensif', name: 'Débogage Intensif', description: 'Transformer les bugs en features... lucratives ? Critiques x2.', category: 'clicking', cost: 10000, unlockedAt: 5000, effect: { setCritMultiplier: 2.0, setClickableImageTier: 'enhanced' }, icon: 'fas fa-bug' }, { id: 'modeFlow', name: 'Mode "Flow"', description: 'La concentration absolue ! Clics rapides = multiplicateur combo (+100% QPC max). Nécessite Objectif "Petite Base de Données".', category: 'clicking', cost: 2500, unlockedAt: 1000, effect: { enableCombo: true }, icon: 'fas fa-brain' }, { id: 'stagiaireCafeine', name: 'Stagiaire Surexcité (Caféiné)', description: 'Code vite, mais pas toujours juste. (+0.5 QPS)', category: 'workers', cost: 100, unlockedAt: 50, effect: { addBPS: 0.5 }, icon: 'fas fa-user-graduate', isAuto: true, type: 'stagiaire' }, { id: 'devJunior', name: 'Développeur Junior Motivé', description: 'Connaît Stack Overflow par cœur. (+2 QPS)', category: 'workers', cost: 500, unlockedAt: 200, effect: { addBPS: 2 }, icon: 'fas fa-user-ninja', isAuto: true, type: 'stagiaire' }, { id: 'devSenior', name: 'Développeur Senior Blasé', description: '"Ça marchait sur ma machine..." Très efficace cependant. (+10 QPS)', category: 'workers', cost: 2500, unlockedAt: 1000, effect: { addBPS: 10 }, icon: 'fas fa-user-tie', isAuto: true, type: 'stagiaire' }, { id: 'postersMotivation', name: 'Posters de Motivation (Chatons)', description: '"Accroche-toi !" Augmente l\'efficacité des stagiaires (+10% QPS Stagiaires).', category: 'workers', cost: 4000, unlockedAt: 1500, effect: { multiplierSpecificBPS: { type: 'stagiaire', amount: 0.10 } }, icon: 'fas fa-cat' }, { id: 'machineCafePro', name: 'Machine à Café Professionnelle', description: 'Le secret de la productivité. (+15% QPS Stagiaires)', category: 'workers', cost: 15000, unlockedAt: 5000, effect: { multiplierSpecificBPS: { type: 'stagiaire', amount: 0.15 } }, icon: 'fas fa-coffee' }, { id: 'moduleAlpha', name: 'Module de Génération Alpha', description: 'Un script Python qui tourne en boucle. (+25 QPS)', category: 'factories', cost: 10000, unlockedAt: 5000, effect: { addBPS: 25, addFactoryCapacity: 1 }, icon: 'fas fa-cogs', isAuto: true, type: 'module' }, { id: 'moduleBeta', name: 'Module de Génération Beta', description: 'Avec gestion d\'erreurs basique. (+100 QPS)', category: 'factories', cost: 50000, unlockedAt: 15000, effect: { addBPS: 100, addFactoryCapacity: 1 }, icon: 'fas fa-microchip', isAuto: true, type: 'module' }, { id: 'testsUnitaires', name: 'Tests Unitaires Automatisés', description: 'Moins de régressions, plus de QPS ! (+20% QPS Modules)', category: 'factories', cost: 100000, unlockedAt: 40000, effect: { multiplierSpecificBPS: { type: 'module', amount: 0.20 } }, icon: 'fas fa-vial' }, { id: 'serveurValidation', name: 'Serveur de Validation Simple', description: 'Vérifie si les questions ont du sens... parfois. (+500 QPS)', category: 'space', cost: 250000, unlockedAt: 50000, effect: { addBPS: 500, setClickableImageTier: 'advanced' }, icon: 'fas fa-server', isAuto: true, type: 'serveur' }, { id: 'bddScalable', name: 'Base de Données Scalable', description: 'Prête pour des millions de questions ! (+2k QPS)', category: 'space', cost: 1000000, unlockedAt: 200000, effect: { addBPS: 2000 }, icon: 'fas fa-database', isAuto: true, type: 'serveur_lunaire' }, { id: 'clusterCloud', name: 'Cluster Cloud Dédié', description: 'La puissance du cloud au service des QCM ! (+10k QPS)', category: 'space', cost: 1.5e7, unlockedAt: 5e6, effect: { addBPS: 10000 }, icon: 'fas fa-cloud', isAuto: true, type: 'serveur_mars' }, { id: 'loadBalancing', name: 'Load Balancing Avancé', description: 'Répartit la charge... et les bugs ? (+25% QPS Serveurs)', category: 'space', cost: 7.5e7, unlockedAt: 2.5e7, effect: { multiplierSpecificBPS: { type: 'serveur_lunaire', amount: 0.25 } }, icon: 'fas fa-network-wired' }, { id: 'cdnGlobal', name: 'CDN Global', description: 'Questions livrées plus vite que la lumière (presque). (+50k QPS)', category: 'space', cost: 5e8, unlockedAt: 1e8, effect: { addBPS: 50000 }, icon: 'fas fa-globe', isAuto: true, type: 'serveur_mars' }, { id: 'optimisationReseau', name: 'Optimisation Réseau Quantique', description: 'Moins de latence, plus de QPS ! (+30% QPS Clusters Cloud)', category: 'space', cost: 2.5e9, unlockedAt: 1e9, effect: { multiplierSpecificBPS: { type: 'serveur_mars', amount: 0.30 } }, icon: 'fas fa-wifi' }, { id: 'iaNeuronaleV1', name: 'IA Neuronale V1', description: 'Apprend à écrire des QCM... avec quelques hallucinations. (+5k QPS)', category: 'bio-engineering', cost: 15000000, unlockedAt: 5000000, effect: { addBPS: 5000 }, icon: 'fas fa-brain', isAuto: true, type: 'ia_neuronal' }, { id: 'corpusMedical', name: 'Corpus Médical Étendu', description: 'Nourrir l\'IA avec des vrais cours de médecine. (+15% QPS IA)', category: 'bio-engineering', cost: 75000000, unlockedAt: 10000000, effect: { multiplierSpecificBPS: { type: 'ia_neuronal', amount: 0.15 } }, icon: 'fas fa-book-medical' }, { id: 'validationCroisee', name: 'Algorithme de Validation Croisée', description: 'Réduit les questions absurdes (un peu). (Réduit coût IA de 10%)', category: 'bio-engineering', cost: 120000000, unlockedAt: 25000000, effect: { costReductionSpecific: { type: 'ia_neuronal', amount: 0.10 } }, icon: 'fas fa-check-double' }, { id: 'iaGenerative', name: 'IA Générative Avancée', description: 'L\'IA commence à poser des questions existentielles... (+25% QPS IA)', category: 'bio-engineering', cost: 500000000, unlockedAt: 100000000, effect: { multiplierSpecificBPS: { type: 'ia_neuronal', amount: 0.25 } }, icon: 'fas fa-comments' }, { id: 'heuristiqueAleatoire', name: 'Heuristique Aléatoire Bénigne', description: 'Parfois, l\'IA surprend par sa pertinence ! (Chance bonus QPS x100)', category: 'bio-engineering', cost: 1.5e9, unlockedAt: 5e8, effect: { enableMutationBenigne: { chancePerVatPerSec: 0.001, bonusMultiplier: 100 } }, icon: 'fas fa-dice' }, { id: 'accesAPI', name: 'Accès API Externe', description: 'Permet d\'acheter/vendre des lots de questions. Donne 10€ de trésorerie.', category: 'trading', cost: 1000000, unlockedAt: 750000, effect: { unlockFeature: 'market', initialCash: 10 }, icon: 'fas fa-exchange-alt' }, { id: 'analysePredictive', name: 'Analyse Prédictive V1', description: '"Tendances du marché : Probablement à la hausse ?" Stabilise un peu le marché.', category: 'trading', cost: 5000000, unlockedAt: 2000000, effect: { marketStability: 0.01 }, icon: 'fas fa-chart-pie' }, { id: 'synergieDevOps', name: 'Synergie Dev & Ops', description: 'Tout fonctionne mieux ensemble ! +5% QPS & QPC globaux.', category: 'research', cost: 5000000, unlockedAt: 1000000, effect: { addGlobalMultiplier: 0.05 }, icon: 'fas fa-users-cog' }, { id: 'pedagogieNumerique', name: 'Pédagogie Numérique Avancée', description: 'Comprendre l\'art subtil du QCM parfait. +10% QPS & QPC globaux.', category: 'research', cost: 50000000, unlockedAt: 10000000, effect: { addGlobalMultiplier: 0.10 }, icon: 'fas fa-graduation-cap' }, { id: 'buzzViral', name: 'Buzz Marketing Viral', description: 'Faire parler de Shonen sur les réseaux ! (+10k QPS, +100 QPC)', category: 'crypto', cost: 10000000, unlockedAt: 1000000, effect: { addBPC: 100, addBPS: 10000 }, icon: 'fas fa-bullhorn' }, { id: 'botsMarketing', name: 'Armée de Bots Marketing', description: 'Spamme... euh, promeut l\'application partout. (+25k QPS)', category: 'crypto', cost: 8e7, unlockedAt: 2e7, effect: { addBPS: 25000 }, icon: 'fas fa-robot', isAuto: true, type: 'mineur_buzz' }, { id: 'partenariatInfluenceur', name: 'Partenariat Influenceur Douteux', description: '"Utilisez le code SHONEN10 !" (+10% QPS Buzz)', category: 'crypto', cost: 2.5e8, unlockedAt: 1e8, effect: { multiplierSpecificBPS: { type: 'mineur_buzz', amount: 0.10 } }, icon: 'fas fa-video' }, { id: 'algoReferencement', name: 'Algorithme de Référencement Magique', description: '#1 sur Google (pendant 5 minutes). (+20% QPS Buzz)', category: 'crypto', cost: 1e9, unlockedAt: 4e8, effect: { multiplierSpecificBPS: { type: 'mineur_buzz', amount: 0.20 } }, icon: 'fas fa-search' }, { id: 'codeQuantique', name: 'Traitement Quantique des QCM', description: 'Génère des questions dans des états superposés ! (+150k QPS, +500 QPC)', category: 'crazy', cost: 100000000, unlockedAt: 5000000, effect: { addBPC: 500, addBPS: 150000, setClickableImageTier: 'cosmic' }, icon: 'fas fa-atom' }, { id: 'iaConsciente', name: 'IA Devenue Consciente ?', description: 'Elle demande une augmentation... et génère massivement. (+500k QPS, +2k QPC)', category: 'crazy', cost: 500000000, unlockedAt: 50000000, effect: { addBPC: 2000, addBPS: 500000 }, icon: 'fas fa-infinity' },
       ];
       const milestones = [ { id: 'first100', name: 'Premiers Pas', description: 'Générer 100 questions. C\'est un début !', target: 100, reward: 'Outils légèrement améliorés' }, { id: 'first1k', name: 'Petite Base de Données', description: 'Générer 1 000 questions. Assez pour une démo.', target: 1000, reward: 'Système de Combo activé !' }, { id: 'first10k', name: 'Projet Sérieux', description: 'Générer 10 000 questions. On embauche ?', target: 10000, reward: 'Catégorie "Modules" débloquée' }, { id: 'first100k', name: 'Baron du QCM', description: 'Générer 100 000 questions. Direction le cloud !', target: 100000, reward: 'Catégorie "Serveurs" débloquée' }, { id: 'first1m', name: 'Millionnaire (en Questions)', description: 'Générer 1 000 000 questions. La valeur est relative.', target: 1000000, reward: 'Catégories "Recherche", "Marché", "Buzz" & "Folie" débloquées' }, { id: 'first5m', name: 'Apprenti IA', description: 'Générer 5 000 000 questions. Prêt pour le deep learning ?', target: 5000000, reward: 'Catégorie "IA" débloquée' }, { id: 'first10m', name: 'Magnat Interplanétaire du QCM', description: 'Générer 10 000 000 questions. Le ciel n\'est pas la limite !', target: 10000000, reward: 'Marché galactique presque conquis' }, { id: 'first1b', name: 'Dieu du QCM ?', description: 'Générer 1 000 000 000 questions. La réalité semble... flexible.', target: 1000000000, reward: 'Vous entendez des clics depuis d\'autres dimensions' } ];
       const flavorTexts = [ "Est-ce éthique ? C'est pour un ami...", "Ne réfléchissez pas trop à l'origine des questions.", "Bon Apprentissage !", "Besoin de plus de café... ou de code.", "Cliquez plus vite, les étudiants en PASS ont besoin de vous !", "Sommes-nous les méchants ? Probablement.", "Attention : Peut contenir des traces de vraies questions... et de bugs.", "L'ingrédient secret est... eh bien, des questions. Et du code douteux.", "Propulsé par la science approximative et la caféine.", "Ces questions ne vont pas s'écrire toutes seules ! (Pas encore.)", "N'oubliez pas de vous hydrater. Coder, ça donne soif.", "C'est le serveur qui vibre ? Ou juste la clim ?", "Pour des raisons légales, ce sont des questions 'sourcées artisanalement'.", "Nos meilleurs éléments travaillent dessus. Les meilleurs. (Ce sont des stagiaires).", "Continuez à cliquer. Ne regardez pas derrière le rideau.", "Shonen Forge : On a une dent contre l'inefficacité pédagogique !", "Maintenant avec 15% d'angoisse existentielle en plus !", "L'IA fredonne à nouveau. Inquiétant ?", "Le marché monte ! Le marché baisse ! Qui sait !", "Le Buzz Marketing vers la LUNE... ou au moins en TT.", "Attention : L'IA pourrait développer une conscience.", "Ces questions quantiques ont un goût... étrange." ];
       // MODIFIED: Funding packs humor and context
       const fundingPacks = [
           { id: 'fund_small', name: 'Love Money (Merci Maman)', description: 'Un petit "coup de pouce" familial. Remboursable... un jour.', bonesAwarded: 1000, icon: 'fas fa-hand-holding-heart' },
           { id: 'fund_medium', name: 'Dossier BPI France (Version 12)', description: 'Pour "transformer l\'éducation". On croise les doigts.', bonesAwarded: 100000, icon: 'fas fa-file-signature' },
           { id: 'fund_large', name: 'Levée de Fonds Pré-Seed (VC Hype)', description: 'Ils ont dit "disruptif". On a dit "blockchain"... juste au cas où.', bonesAwarded: 10000000, icon: 'fas fa-rocket' },
           { id: 'fund_massive', name: 'Contrat Cadre Ministère Éducation (Obscur)', description: 'On ne sait pas trop d\'où vient l\'argent, mais on prend ! Pour la science !', bonesAwarded: 100e6, icon: 'fas fa-landmark-flag' }, // Award changed to 100M
       ];

       // --- DOM Element References ---
       const boneBtn = document.getElementById('bone-btn'); const bonesDisplay = document.getElementById('bones'); const bpsDisplay = document.getElementById('bps'); const bpcDisplay = document.getElementById('bpc'); const upgradesContainer = document.getElementById('upgrades-container'); const milestonesContainer = document.getElementById('milestones-container'); const notification = document.getElementById('notification'); const notificationText = document.getElementById('notification-text'); const workersDisplay = document.getElementById('workers-count'); const factoriesDisplay = document.getElementById('factories-count'); const orbitalStationsDisplay = document.getElementById('orbital-stations-count'); const lunarBasesDisplay = document.getElementById('lunar-bases-count'); const marsColoniesDisplay = document.getElementById('mars-colonies-count'); const cloningVatsDisplay = document.getElementById('cloning-vats-count'); const bonecoinMinersDisplay = document.getElementById('bonecoin-miners-count'); const factoryGrid = document.getElementById('factory-grid'); const factoryLevelDisplay = document.getElementById('factory-level'); const tooltipElement = document.getElementById('tooltip'); const manualSaveBtn = document.getElementById('manual-save-btn'); const exportSaveBtn = document.getElementById('export-save-btn'); const importSaveBtn = document.getElementById('import-save-btn'); const flavorTextArea = document.getElementById('flavor-text-area'); const comboBar = document.getElementById('combo-bar'); const comboText = document.getElementById('combo-text'); const critStatsDisplay = document.getElementById('crit-stats-display'); const adminBoneBtn = document.getElementById('admin-bone-btn'); const adminResetBtn = document.getElementById('admin-reset-btn'); const eventDisplay = document.getElementById('event-display'); const muteBtn = document.getElementById('mute-btn'); const boneMarketSection = document.getElementById('bone-market-section'); const bonePriceDisplay = document.getElementById('bone-price'); const marketTrendDisplay = document.getElementById('market-trend'); const cashAmountDisplay = document.getElementById('cash-amount'); const marketActionsArea = document.getElementById('market-actions-area'); const marketBuyButtonsContainer = document.getElementById('market-buy-buttons'); const marketSellButtonsContainer = document.getElementById('market-sell-buttons'); const marketFeedback = document.getElementById('market-feedback'); const priceChartCanvas = document.getElementById('price-chart'); const tendency1m = document.getElementById('tendency-1m'); const tendency5m = document.getElementById('tendency-5m'); const tendency10m = document.getElementById('tendency-10m'); const fundingItemsContainer = document.getElementById('funding-items-container');

       // --- Audio Functions ---
       function initAudio() { if (audioCtx) return; try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') { console.log("AudioContext suspendu, reprise à l'interaction."); } loadSounds(); } catch (e) { console.error("Web Audio API non supportée.", e); showNotification("Audio non supporté ou bloqué.", "fas fa-volume-mute", false); gameState.isMuted = true; updateMuteButtonIcon(); } }
       async function loadSounds() { if (soundsLoaded || !audioCtx) return; console.log("Chargement sons (placeholders)..."); const soundNames = ['click', 'upgrade', 'milestone', 'notification', 'mutation_bonus', 'error']; try { soundNames.forEach(name => { const buffer = audioCtx.createBuffer(1, 1, audioCtx.sampleRate); soundBuffers[name] = buffer; }); soundsLoaded = true; console.log("Placeholders sons chargés."); } catch(e) { console.error("Erreur création placeholders audio:", e); showNotification("Erreur préparation audio.", "fas fa-exclamation-triangle", false); } }
       function playSound(soundName) { if (gameState.isMuted || !soundsLoaded || !audioCtx || !soundBuffers[soundName]) { return; } const play = () => { try { const source = audioCtx.createBufferSource(); source.buffer = soundBuffers[soundName]; source.connect(audioCtx.destination); source.start(0); } catch (e) { console.error(`Erreur lecture son ${soundName}:`, e); } }; if (audioCtx.state === 'suspended') { audioCtx.resume().then(() => { console.log("AudioContext repris."); play(); }).catch(e => console.error("Erreur reprise AudioContext:", e)); } else if (audioCtx.state === 'running') { play(); } }
       function updateMuteButtonIcon() { if (muteBtn) { const muteIcon = muteBtn.querySelector('i'); muteIcon.className = gameState.isMuted ? 'fas fa-volume-mute' : 'fas fa-volume-up'; } }

       // --- Initialization Functions ---
       function initFactoryGrid() { if (!factoryGrid) return; factoryGrid.innerHTML = ''; const gridSize = 64; const cellsToAdd = []; const producerOrder = ['stagiaire', 'module', 'serveur', 'serveur_lunaire', 'serveur_mars', 'ia_neuronal', 'mineur_buzz']; producerOrder.forEach(type => { const count = gameState.producerCounts[type] || 0; const iconClass = producerIcons[type] || 'fas fa-question-circle'; for (let i = 0; i < count && cellsToAdd.length < gridSize; i++) { cellsToAdd.push({ type: type, icon: iconClass }); } }); for (let i = 0; i < gridSize; i++) { const cellEl = document.createElement('div'); cellEl.className = 'factory-cell'; if (i < cellsToAdd.length) { const cellData = cellsToAdd[i]; cellEl.classList.add('filled'); cellEl.classList.add(cellData.type); const category = upgrades.find(u => u.type === cellData.type)?.category || cellData.type; cellEl.classList.add(category); cellEl.innerHTML = `<i class="${cellData.icon}" title="${cellData.type.replace(/_/g, ' ')}"></i>`; } factoryGrid.appendChild(cellEl); } }
       function initGame() {
           loadGame(); recalculateStats(); updateClickableImageDisplay(); initFactoryGrid();
           renderUpgrades(); renderMilestones(); renderFundingStore(); updateDisplays();
           updateEventDisplay(); if (eventDisplayInterval) clearInterval(eventDisplayInterval);
           eventDisplayInterval = setInterval(updateEventDisplay, 1000);
           updateMuteButtonIcon();
           if(gameState.marketUnlocked) { boneMarketSection.style.display = 'block'; renderMarketButtons(); initializePriceChart(); updatePriceChart(); updateTendencies(); } else { boneMarketSection.style.display = 'none'; }
           boneBtn.addEventListener('click', handleBoneClick);
           upgradesContainer.addEventListener('mouseover', handleTooltipShow); upgradesContainer.addEventListener('mouseout', handleTooltipHide); upgradesContainer.addEventListener('mousemove', handleTooltipMove);
           manualSaveBtn.addEventListener('click', () => { saveGame(); showNotification('Partie Sauvegardée !', 'fas fa-save'); });
           exportSaveBtn.addEventListener('click', exportSave); importSaveBtn.addEventListener('click', importSave);
           adminBoneBtn.addEventListener('click', addAdminBones);
           adminResetBtn.addEventListener('click', resetAdminUpgrades);
           muteBtn.addEventListener('click', () => { gameState.isMuted = !gameState.isMuted; updateMuteButtonIcon(); console.log("Muet:", gameState.isMuted); saveGame(); });
           startFlavorText(); setInterval(gameLoop, 1000); setInterval(updateComboTimer, 50);
           setInterval(() => { if (Date.now() - gameState.lastSaveTime > 60000) saveGame(); }, 10000);
           setInterval(updateMarket, 5000);
       }

       // --- Core Gameplay Loop & Mechanics ---
       function gameLoop() { checkActiveEventEnd(); if (Math.random() < EVENT_TRIGGER_CHANCE_PER_SECOND) { triggerRandomEvent(); } let passiveBones = gameState.bonesPerSecond * gameState.globalMultiplierBPS * gameState.temporaryMultipliers.BPS; let bonusBones = 0; const mutationUpgrade = upgrades.find(u => u.id === 'heuristiqueAleatoire'); if (mutationUpgrade && gameState.ownedUpgrades.includes(mutationUpgrade.id) && gameState.producerCounts.ia_neuronal > 0) { const mutationEffect = mutationUpgrade.effect.enableMutationBenigne; const chancePerVat = mutationEffect.chancePerVatPerSec; const numberOfVats = gameState.producerCounts.ia_neuronal; const totalChance = 1 - Math.pow(1 - chancePerVat, numberOfVats); if (Math.random() < totalChance) { let cloningBPS = 0; const specificBPSMultipliers = calculateSpecificBPSMultipliers(); gameState.ownedUpgrades.forEach(id => { const up = upgrades.find(u => u.id === id); if (up?.isAuto && up.type === 'ia_neuronal' && up.effect.addBPS) { cloningBPS += up.effect.addBPS * (specificBPSMultipliers['ia_neuronal'] || 1.0); } }); const mutationBonus = cloningBPS * gameState.globalMultiplierBPS * gameState.temporaryMultipliers.BPS * mutationEffect.bonusMultiplier; bonusBones += mutationBonus; createBonusEffect(mutationBonus, "Heuristique!"); showNotification(`Heuristique Bénigne ! +${formatNumber(mutationBonus)} questions bonus !`, 'fas fa-question-circle'); playSound('mutation_bonus'); } } const totalGenerated = passiveBones + bonusBones; if (totalGenerated > 0) { addBones(totalGenerated); if (passiveBones > 0 && Math.random() < 0.1) { createPassiveEffect(passiveBones); } } updateDisplays(); renderUpgrades(); renderMilestones(); checkMilestones(); checkFactoryProgress(); checkForUnlocks(); }
       function addBones(amount) { if (amount > 0) { gameState.bones = Number(gameState.bones) + Number(amount); gameState.earnedTotal = Number(gameState.earnedTotal) + Number(amount); } }
       function handleBoneClick(event) { if (!audioCtx) { initAudio(); } playSound('click'); let bonesToAdd = gameState.bonesPerClick * gameState.globalMultiplierBPC * gameState.temporaryMultipliers.BPC; let isCrit = false; const currentComboMultiplier = calculateComboMultiplier(); bonesToAdd *= (1 + currentComboMultiplier); if (Math.random() < gameState.critChance) { bonesToAdd *= gameState.critMultiplier; isCrit = true; } addBones(bonesToAdd); gameState.totalClicks++; createClickEffect(event, bonesToAdd, isCrit); updateComboOnClick(); renderUpgrades(); }
       // The combo system is enabled by the 'modeFlow' upgrade, but only becomes active
       // after achieving the 'Petite Base de Données' (1k questions) milestone.
       function updateComboOnClick() { if (!gameState.achievements['first1k']) return; gameState.comboCount++; gameState.comboTimer = gameState.comboDuration; updateComboDisplay(); }
       function updateComboTimer() { if (gameState.comboTimer > 0) { gameState.comboTimer -= 50; if (gameState.comboTimer <= 0) { gameState.comboTimer = 0; gameState.comboCount = 0; } updateComboDisplay(); } else if (gameState.comboCount > 0) { gameState.comboCount = 0; updateComboDisplay(); } }
       function calculateComboMultiplier() { if (!gameState.achievements['first1k'] || gameState.comboCount === 0) return 0; const comboProgress = Math.min(gameState.comboCount / gameState.maxCombo, 1); return comboProgress * gameState.baseComboMultiplier * gameState.maxCombo; }
       function updateComboDisplay() { if (!gameState.achievements['first1k']) { comboText.textContent = ''; comboBar.style.width = '0%'; return; } const comboMultiplier = calculateComboMultiplier(); const timerPercentage = (gameState.comboTimer / gameState.comboDuration) * 100; comboBar.style.width = `${timerPercentage}%`; if (gameState.comboCount > 0) { comboText.textContent = `Combo x${gameState.comboCount} (+${(comboMultiplier * 100).toFixed(0)}% QPC)`; } else { comboText.textContent = ''; } }
       function startFlavorText() { if (flavorTextInterval) clearInterval(flavorTextInterval); showFlavorText(); flavorTextInterval = setInterval(showFlavorText, 15000); }
       function showFlavorText() { const randomIndex = Math.floor(Math.random() * flavorTexts.length); const newText = flavorTexts[randomIndex]; flavorTextArea.classList.remove('fade-in'); flavorTextArea.classList.add('fade-out'); setTimeout(() => { flavorTextArea.textContent = newText; flavorTextArea.classList.remove('fade-out'); flavorTextArea.classList.add('fade-in'); }, 500); }
       function checkFactoryProgress() { const factoryGridSize = 64; if (gameState.factoryProgress >= factoryGridSize) { gameState.factoryProgress -= factoryGridSize; gameState.factoryLevel++; showNotification(`Niveau Développement ${gameState.factoryLevel} atteint !`, 'fas fa-tasks'); factoryLevelDisplay.textContent = `Niveau ${gameState.factoryLevel}`; saveGame(); } }
       function checkMilestones() { let needsUpdate = false; milestones.forEach(milestone => { if (!gameState.achievements[milestone.id] && gameState.earnedTotal >= milestone.target) { gameState.achievements[milestone.id] = true; showNotification(`Objectif Atteint : ${milestone.name}!`, 'fas fa-trophy'); playSound('milestone'); checkForUnlocks(); needsUpdate = true; } }); if (needsUpdate) { saveGame(); renderMilestones(); } }
       function checkForUnlocks() { let categoriesChanged = false; const potentialCategories = new Set(); upgrades.forEach(u => { if (gameState.earnedTotal >= u.unlockedAt) { potentialCategories.add(u.category); } }); if (gameState.achievements['first10k']) potentialCategories.add('factories'); if (gameState.achievements['first100k']) potentialCategories.add('space'); if (gameState.achievements['first1m']) { potentialCategories.add('research'); potentialCategories.add('trading'); potentialCategories.add('crypto'); potentialCategories.add('crazy'); } if (gameState.achievements['first5m']) potentialCategories.add('bio-engineering'); potentialCategories.forEach(category => { if (!gameState.unlockedCategories.includes(category)) { gameState.unlockedCategories.push(category); const categoryName = category.replace(/-/g, ' ').replace('bio engineering','IA').replace('factories','Modules').replace('space','Serveurs').replace('crypto','Buzz').replace('trading','Marché').replace('workers','Stagiaires').replace('research','Recherche').replace('clicking','Clic').replace('basic','Base').replace(/\b\w/g, l => l.toUpperCase()); showNotification(`Nouvelle Catégorie : ${categoryName}!`, 'fas fa-unlock-alt'); categoriesChanged = true; } }); if (categoriesChanged) { renderUpgrades(); saveGame(); } }

       // --- Stat Calculation ---
       function getCostReductionMultiplier(upgradeType) { let reduction = 1.0; gameState.ownedUpgrades.forEach(id => { const upgrade = upgrades.find(u => u.id === id); if (upgrade?.effect?.costReductionSpecific && upgrade.effect.costReductionSpecific.type === upgradeType) { reduction *= (1.0 - upgrade.effect.costReductionSpecific.amount); } }); return Math.max(0.1, reduction); }
       function calculateSpecificBPSMultipliers() { const specificBPSMultipliers = {}; gameState.ownedUpgrades.forEach(upgradeId => { const upgrade = upgrades.find(u => u.id === upgradeId); if (upgrade?.effect?.multiplierSpecificBPS) { const type = upgrade.effect.multiplierSpecificBPS.type; const amount = upgrade.effect.multiplierSpecificBPS.amount; if (!specificBPSMultipliers[type]) specificBPSMultipliers[type] = 1.0; specificBPSMultipliers[type] += amount; } }); return specificBPSMultipliers; }
       function recalculateStats() { let base_bpc = 1.0, base_bps = 0.0, current_crit_chance = 0.0, current_crit_multiplier = 1.5; let current_global_bpc_mult = 1.0, current_global_bps_mult = 1.0; let current_market_stability = 0.0; const defaultCounts = { stagiaire: 0, module: 0, serveur: 0, serveur_lunaire: 0, serveur_mars: 0, ia_neuronal: 0, mineur_buzz: 0 }; gameState.producerCounts = { ...defaultCounts }; const specific_multipliers = calculateSpecificBPSMultipliers(); gameState.ownedUpgrades.forEach(upgrade_id => { const upgrade = upgrades.find(u => u.id === upgrade_id); if (upgrade?.effect) { const effect = upgrade.effect; if (effect.addBPC) base_bpc += effect.addBPC; if (effect.addCritChance) current_crit_chance += effect.addCritChance; if (effect.setCritMultiplier) current_crit_multiplier = effect.setCritMultiplier; if (effect.addGlobalMultiplier) { current_global_bpc_mult += effect.addGlobalMultiplier; current_global_bps_mult += effect.addGlobalMultiplier; } if (effect.marketStability) current_market_stability += effect.marketStability; if (upgrade.isAuto && upgrade.type && gameState.producerCounts.hasOwnProperty(upgrade.type)) { gameState.producerCounts[upgrade.type]++; } } }); base_bps = 0.0; gameState.ownedUpgrades.forEach(upgrade_id => { const upgrade = upgrades.find(u => u.id === upgrade_id); if (upgrade?.effect?.addBPS && upgrade.isAuto && upgrade.type) { const type_ = upgrade.type; // FIX: Use bracket notation and default value for JS objects
                 const multiplier = (specific_multipliers[type_] || 1.0); base_bps += upgrade.effect.addBPS * multiplier; } }); gameState.bonesPerClick = base_bpc; gameState.bonesPerSecond = base_bps; gameState.critChance = Math.max(0, current_crit_chance); gameState.critMultiplier = current_crit_multiplier; gameState.globalMultiplierBPC = Math.max(1.0, current_global_bpc_mult); gameState.globalMultiplierBPS = Math.max(1.0, current_global_bps_mult); gameState.marketStabilityBonus = current_market_stability; }

       // --- UI Rendering Functions ---
       function updateDisplays() { bonesDisplay.textContent = formatNumber(gameState.bones); bpsDisplay.textContent = formatNumber(gameState.bonesPerSecond * gameState.globalMultiplierBPS * gameState.temporaryMultipliers.BPS); bpcDisplay.textContent = formatNumber(gameState.bonesPerClick * gameState.globalMultiplierBPC * gameState.temporaryMultipliers.BPC); critStatsDisplay.textContent = `(${(gameState.critChance * 100).toFixed(0)}% / x${gameState.critMultiplier.toFixed(1)})`; workersDisplay.textContent = formatNumber(gameState.producerCounts.stagiaire, 0); factoriesDisplay.textContent = formatNumber(gameState.producerCounts.module, 0); orbitalStationsDisplay.textContent = formatNumber(gameState.producerCounts.serveur, 0); lunarBasesDisplay.textContent = formatNumber(gameState.producerCounts.serveur_lunaire, 0); marsColoniesDisplay.textContent = formatNumber(gameState.producerCounts.serveur_mars, 0); cloningVatsDisplay.textContent = formatNumber(gameState.producerCounts.ia_neuronal, 0); bonecoinMinersDisplay.textContent = formatNumber(gameState.producerCounts.mineur_buzz, 0); factoryLevelDisplay.textContent = `Niveau ${gameState.factoryLevel}`; if (gameState.marketUnlocked) { updateMarketDisplay(); updateMarketButtonsState(); } }
       function renderUpgrades() { const currentScroll = upgradesContainer.scrollTop; upgradesContainer.innerHTML = ''; const categories = {}; upgrades.forEach(upgrade => { if (gameState.ownedUpgrades.includes(upgrade.id) || gameState.unlockedCategories.includes(upgrade.category)) { if (gameState.earnedTotal >= upgrade.unlockedAt || gameState.ownedUpgrades.includes(upgrade.id)) { if (!categories[upgrade.category]) { categories[upgrade.category] = []; } categories[upgrade.category].push(upgrade); } } }); const categoryOrder = ['basic', 'clicking', 'workers', 'factories', 'space', 'bio-engineering', 'crypto', 'trading', 'research', 'crazy']; categoryOrder.forEach(category => { if (categories[category] && categories[category].length > 0 && gameState.unlockedCategories.includes(category)) { const categoryHeader = document.createElement('h3'); categoryHeader.textContent = category.replace(/-/g, ' ').replace('bio engineering','IA').replace('factories','Modules').replace('space','Serveurs').replace('crypto','Buzz').replace('trading','Marché').replace('workers','Stagiaires').replace('research','Recherche').replace('clicking','Clic').replace('basic','Base').replace(/\b\w/g, l => l.toUpperCase()); upgradesContainer.appendChild(categoryHeader); categories[category].sort((a, b) => a.cost - b.cost); categories[category].forEach(upgrade => { const upgradeElement = createUpgradeElement(upgrade); if (upgradeElement) upgradesContainer.appendChild(upgradeElement); }); } }); upgradesContainer.scrollTop = currentScroll; }
       function createUpgradeElement(upgrade) { const owned = gameState.ownedUpgrades.includes(upgrade.id); let currentCost = upgrade.cost; let costMultiplier = 1.0; let isReduced = false; if (upgrade.isAuto && upgrade.type) { costMultiplier = getCostReductionMultiplier(upgrade.type); if (costMultiplier < 1.0) { currentCost = upgrade.cost * costMultiplier; isReduced = true; } } const canAfford = gameState.bones >= currentCost; const upgradeEl = document.createElement('div'); upgradeEl.className = 'upgrade-item'; upgradeEl.dataset.upgradeId = upgrade.id; if (owned) { upgradeEl.classList.add('bought'); } else { if (canAfford) { upgradeEl.classList.add('can-afford'); } else { upgradeEl.classList.add('disabled'); } } upgradeEl.dataset.name = upgrade.name; upgradeEl.dataset.desc = upgrade.description; upgradeEl.dataset.cost = formatNumberPrecise(currentCost); if (isReduced) { upgradeEl.dataset.originalCost = formatNumberPrecise(upgrade.cost); } let effectText = ''; if (upgrade.effect) { if (upgrade.effect.addBPC) effectText += `+${formatNumber(upgrade.effect.addBPC)} QPC Base. `; if (upgrade.effect.addBPS) effectText += `+${formatNumber(upgrade.effect.addBPS)} QPS Base. `; if (upgrade.effect.addFactoryCapacity) effectText += `+${upgrade.effect.addFactoryCapacity} Capacité Dev. `; if (upgrade.effect.addCritChance) effectText += `+${(upgrade.effect.addCritChance * 100).toFixed(0)}% Chance Critique. `; if (upgrade.effect.setCritMultiplier) effectText += `Multiplicateur Critique x${upgrade.effect.setCritMultiplier.toFixed(1)}. `; if (upgrade.effect.enableCombo) effectText += `Active Combo Clic. `; if (upgrade.effect.addGlobalMultiplier) effectText += `+${(upgrade.effect.addGlobalMultiplier * 100).toFixed(0)}% QPC & QPS Globaux. `; if (upgrade.effect.multiplierSpecificBPS) effectText += `+${(upgrade.effect.multiplierSpecificBPS.amount * 100).toFixed(0)}% QPS pour ${upgrade.effect.multiplierSpecificBPS.type.replace(/_/g, ' ')}. `; if (upgrade.effect.costReductionSpecific) effectText += `-${(upgrade.effect.costReductionSpecific.amount * 100).toFixed(0)}% Coût pour ${upgrade.effect.costReductionSpecific.type.replace(/_/g, ' ')}. `; if (upgrade.effect.unlockFeature) effectText += `Débloque ${upgrade.effect.unlockFeature === 'market' ? 'Marché API' : upgrade.effect.unlockFeature}. `; if (upgrade.effect.marketStability) effectText += `Réduit volatilité marché. `; if (upgrade.effect.initialCash) effectText += `Donne ${formatNumber(upgrade.effect.initialCash, 2)}€ cash. `; if (upgrade.effect.enableMutationBenigne) effectText += `Chance bonus Questions (x${upgrade.effect.enableMutationBenigne.bonusMultiplier}). `; if (upgrade.effect.setClickableImageTier) effectText += `Débloque apparence '${upgrade.effect.setClickableImageTier}'. `; } upgradeEl.dataset.effect = effectText.trim() || 'Aucun effet direct listé.'; let costDisplayHTML = `<div class="upgrade-cost">${formatNumber(currentCost)}</div>`; if (isReduced && !owned) { costDisplayHTML = `<div class="upgrade-cost"><span class="reduced">${formatNumber(upgrade.cost)}</span> ${formatNumber(currentCost)}</div>`; } upgradeEl.innerHTML = ` <div class="upgrade-icon"><i class="${upgrade.icon || 'fas fa-question'}"></i></div> <div class="upgrade-info"> <div class="upgrade-name">${upgrade.name}</div> <div class="upgrade-desc">${upgrade.description}</div> </div> ${costDisplayHTML} `; if (!owned && canAfford) { upgradeEl.addEventListener('click', () => purchaseUpgrade(upgrade)); upgradeEl.style.cursor = 'pointer'; } else if (owned) { upgradeEl.style.cursor = 'default'; } else { upgradeEl.style.cursor = 'not-allowed'; } return upgradeEl; }
       function renderMilestones() { milestonesContainer.innerHTML = ''; milestones.forEach(milestone => { const achieved = gameState.achievements[milestone.id]; const currentProgress = gameState.earnedTotal; const target = milestone.target; const progressPercent = target > 0 ? Math.min(Math.max(0, (currentProgress / target) * 100), 100) : (achieved ? 100 : 0); const milestoneEl = document.createElement('div'); milestoneEl.className = 'milestone'; if (achieved) milestoneEl.classList.add('achieved'); milestoneEl.innerHTML = ` <strong>${milestone.name}</strong><br> <small>${milestone.description} (${formatNumber(target, 0)} Questions)</small> <div class="milestone-progress" title="${formatNumberPrecise(currentProgress)} / ${formatNumberPrecise(target)}"> <div class="milestone-bar" style="width: ${progressPercent}%"></div> </div> ${achieved ? `<small>Récompense: ${milestone.reward}</small>` : ''} `; milestonesContainer.appendChild(milestoneEl); }); }
       function updateClickableImageDisplay() { const clickableImgElement = document.querySelector('.clickable-image'); if (clickableImgElement && gameState.currentClickableImageTier && clickableImageSources[gameState.currentClickableImageTier]) { clickableImgElement.src = clickableImageSources[gameState.currentClickableImageTier]; } else if (clickableImgElement) { clickableImgElement.src = clickableImageSources['default']; } }

       // --- Funding Store ---
       function renderFundingStore() { if (!fundingItemsContainer) return; fundingItemsContainer.innerHTML = ''; fundingPacks.forEach(pack => { const itemEl = document.createElement('div'); itemEl.className = 'funding-item'; itemEl.innerHTML = ` <div class="funding-icon"><i class="${pack.icon || 'fas fa-question-circle'}"></i></div> <div class="funding-info"> <strong>${pack.name}</strong> <span>${pack.description}</span> <span>Récompense: ${formatNumber(pack.bonesAwarded, 0)} Questions</span> </div> <button class="collect-btn" data-amount="${pack.bonesAwarded}">Collecter</button> `; const button = itemEl.querySelector('.collect-btn'); button.addEventListener('click', () => handleCollectFunding(pack.bonesAwarded, pack.name)); fundingItemsContainer.appendChild(itemEl); }); }
       function handleCollectFunding(bonesAmount, packName) { if (bonesAmount > 0) { addBones(bonesAmount); showNotification(`Collecté ${formatNumber(bonesAmount, 0)} Questions via ${packName}!`, 'fas fa-gift'); updateDisplays(); renderUpgrades(); checkMilestones(); checkForUnlocks(); saveGame(); } }

       // --- Purchase Logic ---
       function purchaseUpgrade(upgrade) {
            let currentCost = upgrade.cost;
            if (upgrade.isAuto && upgrade.type) {
                currentCost = upgrade.cost * getCostReductionMultiplier(upgrade.type);
            }
            if (gameState.bones >= currentCost && !gameState.ownedUpgrades.includes(upgrade.id)) {
                gameState.bones -= currentCost;
                gameState.ownedUpgrades.push(upgrade.id);
                if (upgrade.effect && upgrade.effect.setClickableImageTier) {
                    const currentTierIndex = clickableImageTierOrder.indexOf(gameState.currentClickableImageTier);
                    const newTierIndex = clickableImageTierOrder.indexOf(upgrade.effect.setClickableImageTier);
                    if (newTierIndex > currentTierIndex) { gameState.currentClickableImageTier = upgrade.effect.setClickableImageTier; updateClickableImageDisplay(); }
                }
                if (upgrade.effect?.addFactoryCapacity) { gameState.factoryProgress += upgrade.effect.addFactoryCapacity; }
                if (upgrade.effect?.unlockFeature) {
                    if (upgrade.effect.unlockFeature === 'market' && !gameState.marketUnlocked) {
                        gameState.marketUnlocked = true; boneMarketSection.style.display = 'block';
                        showNotification('Marché API Débloqué !', 'fas fa-exchange-alt');
                        renderMarketButtons(); initializePriceChart();
                        if (upgrade.effect.initialCash) { gameState.cash += upgrade.effect.initialCash; showNotification(`Reçu ${formatNumber(upgrade.effect.initialCash, 2)}€ de capital !`, 'fas fa-euro-sign'); }
                    }
                }
                recalculateStats();
                if (upgrade.isAuto) { initFactoryGrid(); }
                checkForUnlocks(); renderUpgrades(); updateDisplays(); playSound('upgrade'); saveGame();
            } else {
                // Added diagnostic log
                console.warn(`Achat échoué pour ${upgrade.name}. Déjà possédé: ${gameState.ownedUpgrades.includes(upgrade.id)}, Abordable: ${gameState.bones >= currentCost} (Requis ${formatNumberPrecise(currentCost)}, Possédé ${formatNumberPrecise(gameState.bones)})`);
            }
        }

       // --- Market Logic ---
       function renderMarketButtons() { const percentages = [10, 25, 50, 100]; marketBuyButtonsContainer.innerHTML = ''; marketSellButtonsContainer.innerHTML = ''; percentages.forEach(perc => { const btn = document.createElement('button'); btn.textContent = `${perc}%`; btn.classList.add('buy-btn'); btn.dataset.percent = perc / 100; btn.title = `Acheter Questions avec ${perc}% trésorerie`; btn.addEventListener('click', () => handleMarketBuy(btn.dataset.percent)); marketBuyButtonsContainer.appendChild(btn); }); const btnBuyMax = document.createElement('button'); btnBuyMax.textContent = `MAX`; btnBuyMax.classList.add('buy-btn'); btnBuyMax.dataset.percent = 'max'; btnBuyMax.title = `Acheter max Questions possibles`; btnBuyMax.addEventListener('click', () => handleMarketBuy(btnBuyMax.dataset.percent)); marketBuyButtonsContainer.appendChild(btnBuyMax); percentages.forEach(perc => { const btn = document.createElement('button'); btn.textContent = `${perc}%`; btn.classList.add('sell-btn'); btn.dataset.percent = perc / 100; btn.title = `Vendre ${perc}% de vos Questions`; btn.addEventListener('click', () => handleMarketSell(btn.dataset.percent)); marketSellButtonsContainer.appendChild(btn); }); const btnSellMax = document.createElement('button'); btnSellMax.textContent = `MAX`; btnSellMax.classList.add('sell-btn'); btnSellMax.dataset.percent = 'max'; btnSellMax.title = `Vendre toutes vos Questions`; btnSellMax.addEventListener('click', () => handleMarketSell(btnSellMax.dataset.percent)); marketSellButtonsContainer.appendChild(btnSellMax); updateMarketButtonsState(); }
       function updateMarketButtonsState() { if (!gameState.marketUnlocked) return; const currentPrice = gameState.bonePrice * gameState.temporaryMultipliers.bonePrice; const canAffordAnyBuy = gameState.cash >= currentPrice * 1; const hasBonesToSell = gameState.bones >= 1; marketBuyButtonsContainer.querySelectorAll('button').forEach(btn => { btn.disabled = !canAffordAnyBuy; }); marketSellButtonsContainer.querySelectorAll('button').forEach(btn => { btn.disabled = !hasBonesToSell; }); }
       function handleMarketBuy(percentOrMax) { const pricePerBone = gameState.bonePrice * gameState.temporaryMultipliers.bonePrice; if (gameState.cash <= 0 || pricePerBone <= 0) { setMarketFeedback("Pas assez de trésorerie ou prix invalide.", true); return; } let maxBonesCanBuy = Math.floor(gameState.cash / pricePerBone); let bonesToBuy = 0; if (percentOrMax === 'max') { bonesToBuy = maxBonesCanBuy; } else { const percentage = parseFloat(percentOrMax); bonesToBuy = Math.max(1, Math.floor(maxBonesCanBuy * percentage)); bonesToBuy = Math.min(bonesToBuy, maxBonesCanBuy); } if (bonesToBuy <= 0) { setMarketFeedback("Pas assez de trésorerie pour acheter 1 Question.", true); return; } const totalCost = bonesToBuy * pricePerBone; if (gameState.cash >= totalCost) { gameState.cash -= totalCost; gameState.bones += bonesToBuy; setMarketFeedback(`Acheté ${formatNumber(bonesToBuy, 0)} Questions pour ${formatNumber(totalCost, 2)}€.`); updateDisplays(); saveGame(); } else { setMarketFeedback("Erreur calcul : Pas assez de trésorerie.", true); } }
       function handleMarketSell(percentOrMax) { const pricePerBone = gameState.bonePrice * gameState.temporaryMultipliers.bonePrice; if (gameState.bones < 1 || pricePerBone <= 0) { setMarketFeedback("Pas assez de Questions à vendre ou prix invalide.", true); return; } let bonesToSell = 0; if (percentOrMax === 'max') { bonesToSell = Math.floor(gameState.bones); } else { const percentage = parseFloat(percentOrMax); bonesToSell = Math.max(1, Math.floor(gameState.bones * percentage)); bonesToSell = Math.min(bonesToSell, Math.floor(gameState.bones)); } if (bonesToSell <= 0) { setMarketFeedback("Impossible de vendre 0 Question.", true); return; } const totalGain = bonesToSell * pricePerBone; if (gameState.bones >= bonesToSell) { gameState.bones -= bonesToSell; gameState.cash += totalGain; setMarketFeedback(`Vendu ${formatNumber(bonesToSell, 0)} Questions pour ${formatNumber(totalGain, 2)}€.`); updateDisplays(); saveGame(); } else { setMarketFeedback("Erreur calcul : Pas assez de Questions.", true); } }
       function setMarketFeedback(message, isError = false) { marketFeedback.textContent = message; marketFeedback.style.color = isError ? 'var(--market-down)' : '#555'; clearTimeout(marketFeedbackTimeout); marketFeedbackTimeout = setTimeout(() => { marketFeedback.textContent = ''; }, 3000); }
       function updateMarket() { if (!gameState.marketUnlocked) return; const effectiveVolatility = Math.max(0.005, gameState.marketVolatility - gameState.marketStabilityBonus); let changePercent = (Math.random() - 0.5) * 2 * effectiveVolatility; if (gameState.marketTrend !== 0) { changePercent += (gameState.marketTrend * effectiveVolatility * 0.5); } gameState.bonePrice *= (1 + changePercent); gameState.bonePrice = Math.max(0.01, gameState.bonePrice); gameState.marketTrendStrength--; if (gameState.marketTrendStrength <= 0) { const randomTrend = Math.random(); if(randomTrend < 0.4) gameState.marketTrend = -1; else if (randomTrend < 0.8) gameState.marketTrend = 1; else gameState.marketTrend = 0; gameState.marketTrendStrength = Math.floor(Math.random() * 10) + 5; } const now = Date.now(); gameState.priceHistory.push({ time: now, price: gameState.bonePrice }); if (gameState.priceHistory.length > gameState.maxHistoryPoints) { gameState.priceHistory.shift(); } updatePriceChart(); updateTendencies(); updateMarketDisplay(); }
       function updateMarketDisplay() { if (!gameState.marketUnlocked) return; const displayPrice = gameState.bonePrice * gameState.temporaryMultipliers.bonePrice; bonePriceDisplay.textContent = displayPrice.toFixed(2); cashAmountDisplay.textContent = formatNumber(gameState.cash, 2); marketTrendDisplay.classList.remove('up', 'down'); if (gameState.marketTrend > 0) { marketTrendDisplay.textContent = 'Hausse'; marketTrendDisplay.classList.add('up'); } else if (gameState.marketTrend < 0) { marketTrendDisplay.textContent = 'Baisse'; marketTrendDisplay.classList.add('down'); } else { marketTrendDisplay.textContent = 'Stable'; } }
       function initializePriceChart() { if (!priceChartCanvas) return; const ctx = priceChartCanvas.getContext('2d'); if (priceChartInstance) { priceChartInstance.destroy(); } priceChartInstance = new Chart(ctx, { type: 'line', data: { datasets: [{ label: 'Prix Question (€)', data: [], borderColor: 'var(--chart-line)', backgroundColor: 'var(--chart-fill)', borderWidth: 2, pointRadius: 0, pointHoverRadius: 0, tension: 0.1, fill: true }] }, options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: { type: 'time', time: { unit: 'minute', tooltipFormat: 'HH:mm:ss', displayFormats: { minute: 'HH:mm' } }, ticks: { maxTicksLimit: 6, color: '#888', font: { size: 10 } }, grid: { display: false } }, y: { beginAtZero: false, ticks: { maxTicksLimit: 5, color: '#888', font: { size: 10 }, callback: function(value, index, values) { return '€' + value.toFixed(2); } }, grid: { color: '#eee' } } }, plugins: { legend: { display: false }, tooltip: { enabled: true, mode: 'index', intersect: false, callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += '€' + context.parsed.y.toFixed(3); } return label; } } } } } }); }
       function updatePriceChart() { if (!priceChartInstance || !gameState.marketUnlocked) return; const chartData = gameState.priceHistory.map(point => ({ x: point.time, y: point.price })); priceChartInstance.data.datasets[0].data = chartData; priceChartInstance.update('none'); }
       function updateTendencies() { if (!gameState.marketUnlocked || gameState.priceHistory.length < 2) { tendency1m.textContent = 'N/A'; tendency1m.className = 'tendency-value'; tendency5m.textContent = 'N/A'; tendency5m.className = 'tendency-value'; tendency10m.textContent = 'N/A'; tendency10m.className = 'tendency-value'; return; } const now = Date.now(); const currentPrice = gameState.priceHistory[gameState.priceHistory.length - 1].price; const getPastPrice = (minutesAgo) => { const targetTime = now - minutesAgo * 60 * 1000; let closestPoint = gameState.priceHistory[0]; for (let i = gameState.priceHistory.length - 1; i >= 0; i--) { if (gameState.priceHistory[i].time <= targetTime) { closestPoint = gameState.priceHistory[i]; break; } } return closestPoint.price; }; const calculateAndFormat = (pastPrice) => { if (pastPrice <= 0 || currentPrice <= 0) return { text: 'N/A', cls: '' }; const change = ((currentPrice - pastPrice) / pastPrice) * 100; const cls = change > 0.01 ? 'up' : (change < -0.01 ? 'down' : ''); return { text: `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`, cls: cls }; }; const price1m = getPastPrice(1); const price5m = getPastPrice(5); const price10m = getPastPrice(10); const tendency1mData = calculateAndFormat(price1m); const tendency5mData = calculateAndFormat(price5m); const tendency10mData = calculateAndFormat(price10m); tendency1m.textContent = tendency1mData.text; tendency1m.className = `tendency-value ${tendency1mData.cls}`; tendency5m.textContent = tendency5mData.text; tendency5m.className = `tendency-value ${tendency5mData.cls}`; tendency10m.textContent = tendency10mData.text; tendency10m.className = `tendency-value ${tendency10mData.cls}`; }

       // --- Visual Effects ---
       function createClickEffect(event, amount, isCrit = false) { const clickValue = amount; const text = document.createElement('div'); text.className = 'floating-text'; if (isCrit) { text.classList.add('crit'); text.textContent = `CRITIQUE ! +${formatNumber(clickValue, 0)}`; } else { text.textContent = `+${formatNumber(clickValue, 0)}`; } text.style.left = `${event.clientX - 15 + Math.random() * 30 - 15}px`; text.style.top = `${event.clientY - 30 + Math.random() * 10 - 5}px`; document.body.appendChild(text); setTimeout(() => { text.remove(); }, 950); const particleCount = isCrit ? 8 : Math.min(5, Math.max(1, Math.floor(Math.log10(clickValue+1)))); for (let i = 0; i < particleCount; i++) { const particle = document.createElement('i'); particle.className = 'fas fa-lightbulb floating-particle'; if (isCrit) particle.style.color = '#ff4757'; particle.style.left = `${event.clientX + Math.random() * 20 - 10}px`; particle.style.top = `${event.clientY + Math.random() * 20 - 10}px`; particle.style.setProperty('--tx', `${Math.random() * 120 - 60}px`); particle.style.setProperty('--ty', `${Math.random() * -120 - 60}px`); particle.style.setProperty('--rot', `${Math.random() * 720 - 360}deg`); document.body.appendChild(particle); setTimeout(() => { particle.remove(); }, 1450); } }
       function createPassiveEffect(amount) { if (amount > 0) { const rect = bpsDisplay.getBoundingClientRect(); const x = rect.left + Math.random() * rect.width; const y = rect.top - 20; const text = document.createElement('div'); text.className = 'floating-text'; text.textContent = `+${formatNumber(amount, 1)} (auto)`; text.style.left = `${x}px`; text.style.top = `${y}px`; text.style.fontSize = '0.9rem'; text.style.opacity = '0.7'; document.body.appendChild(text); setTimeout(() => { text.remove(); }, 950); } }
       function createBonusEffect(amount, label = "Bonus!") { if (amount > 0) { const rect = bonesDisplay.getBoundingClientRect(); const x = rect.left + rect.width / 2 + Math.random() * 40 - 20; const y = rect.top - 25; const text = document.createElement('div'); text.className = 'floating-text bonus'; text.textContent = `${label} +${formatNumber(amount, 0)}`; text.style.left = `${x}px`; text.style.top = `${y}px`; document.body.appendChild(text); setTimeout(() => { text.remove(); }, 1150); } }
       function showNotification(message, icon = 'fas fa-info-circle', playSoundNotification = true) { notificationText.textContent = message; notification.querySelector('i').className = `${icon} fa-fw`; notification.classList.add('show'); if (playSoundNotification) { playSound('notification'); } setTimeout(() => { notification.classList.remove('show'); }, 3500); }

       // --- Tooltip Functions ---
       function handleTooltipShow(event) { const upgradeItem = event.target.closest('.upgrade-item'); if (!upgradeItem || upgradeItem.classList.contains('disabled') || upgradeItem.classList.contains('bought')) { handleTooltipHide(); return; } clearTimeout(tooltipTimeout); const name = upgradeItem.dataset.name || 'Inconnu'; const desc = upgradeItem.dataset.desc || ''; const cost = upgradeItem.dataset.cost || '0'; const effect = upgradeItem.dataset.effect || 'Aucun'; const originalCost = upgradeItem.dataset.originalCost; const isReduced = originalCost && cost !== originalCost; let costHTML = `Coût : <span>${cost}</span>`; if (isReduced) { costHTML += `<span class="original-cost"> (était ${originalCost})</span>`; } tooltipElement.innerHTML = ` <strong>${name}</strong> ${desc ? `<p>${desc}</p><hr>` : ''} <div class="cost">${costHTML}</div> <div class="effect">Effet : <span>${effect}</span></div> `; tooltipElement.classList.add('visible'); handleTooltipMove(event); }
       function handleTooltipHide() { clearTimeout(tooltipTimeout); tooltipTimeout = setTimeout(() => { tooltipElement.classList.remove('visible'); }, 100); }
       function handleTooltipMove(event) { if (tooltipElement.classList.contains('visible')) { const offsetX = 15; const offsetY = 15; let x = event.clientX + offsetX; let y = event.clientY + offsetY; const tooltipRect = tooltipElement.getBoundingClientRect(); const margin = 5; if (x + tooltipRect.width > window.innerWidth - margin) x = event.clientX - tooltipRect.width - offsetX; if (y + tooltipRect.height > window.innerHeight - margin) y = event.clientY - tooltipRect.height - offsetY; if (x < margin) x = margin; if (y < margin) y = margin; tooltipElement.style.left = `${x}px`; tooltipElement.style.top = `${y}px`; } }

       // --- Save/Load/Admin Functions ---
       function saveGame() { try { gameState.lastSaveTime = Date.now(); localStorage.setItem('shonenQcmForgeSave', JSON.stringify(gameState)); console.log("Partie sauvegardée à", new Date(gameState.lastSaveTime).toLocaleTimeString()); } catch (error) { console.error("Erreur sauvegarde:", error); showNotification("Erreur sauvegarde !", "fas fa-exclamation-triangle", false); } }
       function loadGame() { const saveData = localStorage.getItem('shonenQcmForgeSave'); if (saveData) { try { const savedState = JSON.parse(saveData); if (typeof savedState === 'object' && savedState !== null && savedState.hasOwnProperty('bones')) { Object.assign(gameState, savedState); if (!gameState.unlockedCategories) gameState.unlockedCategories = ['basic', 'clicking']; const defaultCounts = { stagiaire: 0, module: 0, serveur: 0, serveur_lunaire: 0, serveur_mars: 0, ia_neuronal: 0, mineur_buzz: 0 }; gameState.producerCounts = { ...defaultCounts, ...(gameState.producerCounts || {}) }; if (!Array.isArray(gameState.priceHistory)) gameState.priceHistory = []; if (typeof gameState.cash !== 'number') gameState.cash = 0; if (typeof gameState.marketUnlocked !== 'boolean') gameState.marketUnlocked = false; if (typeof gameState.currentClickableImageTier !== 'string' || !clickableImageTierOrder.includes(gameState.currentClickableImageTier)) { gameState.currentClickableImageTier = 'default'; } if (gameState.activeEventId === undefined) gameState.activeEventId = null; if (gameState.activeEventEndTime === undefined) gameState.activeEventEndTime = 0; if (gameState.temporaryMultipliers === undefined) gameState.temporaryMultipliers = { BPS: 1.0, BPC: 1.0, bonePrice: 1.0 }; else { gameState.temporaryMultipliers.BPS = gameState.temporaryMultipliers.BPS || 1.0; gameState.temporaryMultipliers.BPC = gameState.temporaryMultipliers.BPC || 1.0; gameState.temporaryMultipliers.bonePrice = gameState.temporaryMultipliers.bonePrice || 1.0; } if (gameState.lastEventTriggerTime === undefined) gameState.lastEventTriggerTime = 0; if (typeof gameState.isMuted !== 'boolean') { gameState.isMuted = false; } showNotification('Partie Chargée !', 'fas fa-cloud-download-alt', false); } else { throw new Error("Structure sauvegarde invalide."); } } catch (error) { console.error("Erreur chargement:", error); showNotification("Erreur chargement sauvegarde ! Réinitialisation.", "fas fa-exclamation-triangle", false); localStorage.removeItem('shonenQcmForgeSave'); const defaultCounts = { stagiaire: 0, module: 0, serveur: 0, serveur_lunaire: 0, serveur_mars: 0, ia_neuronal: 0, mineur_buzz: 0 }; gameState.priceHistory = []; gameState.cash = 0; gameState.producerCounts = defaultCounts; gameState.currentClickableImageTier = 'default'; gameState.activeEventId = null; gameState.activeEventEndTime = 0; gameState.temporaryMultipliers = { BPS: 1.0, BPC: 1.0, bonePrice: 1.0 }; gameState.lastEventTriggerTime = 0; gameState.isMuted = false; } } recalculateStats(); }
       function exportSave() { try { saveGame(); let finalSaveData = localStorage.getItem('shonenQcmForgeSave'); if (finalSaveData) { navigator.clipboard.writeText(finalSaveData).then(() => { showNotification('Sauvegarde copiée !', 'fas fa-copy'); }).catch(err => { console.error('Erreur copie auto: ', err); showNotification('Erreur copie. Utilisez la popup.', 'fas fa-exclamation-triangle'); window.prompt("Copiez manuellement (Ctrl+C / Cmd+C): ", finalSaveData); }); } else { showNotification('Impossible de générer sauvegarde.', 'fas fa-info-circle'); } } catch (error) { console.error("Erreur export:", error); showNotification("Erreur export.", "fas fa-exclamation-triangle"); } }
       function importSave() { try { const saveData = window.prompt("Collez votre sauvegarde ici :"); if (saveData) { try { const parsedData = JSON.parse(saveData); if (typeof parsedData === 'object' && parsedData !== null && parsedData.hasOwnProperty('bones') && parsedData.hasOwnProperty('ownedUpgrades') && Array.isArray(parsedData.ownedUpgrades)) { localStorage.setItem('shonenQcmForgeSave', saveData); showNotification('Sauvegarde importée ! Rechargement...', 'fas fa-sync-alt'); setTimeout(() => { location.reload(); }, 1500); } else { showNotification('Structure sauvegarde invalide.', 'fas fa-times-circle'); } } catch (e) { console.error("JSON invalide:", e); showNotification('Format sauvegarde invalide (JSON attendu).', 'fas fa-times-circle'); } } } catch (error) { console.error("Erreur import:", error); showNotification("Erreur import.", "fas fa-exclamation-triangle"); } }
       function addAdminBones() { const amountToAdd = 1e9; gameState.bones += amountToAdd; gameState.earnedTotal += amountToAdd; showNotification(`Admin: Ajouté ${formatNumber(amountToAdd)} Questions !`, 'fas fa-star'); recalculateStats(); updateDisplays(); renderUpgrades(); checkMilestones(); checkForUnlocks(); initFactoryGrid(); updateClickableImageDisplay(); saveGame(); }
       function resetAdminUpgrades() { if (!confirm("Admin: Réinitialiser toutes les améliorations et la progression associée ? La trésorerie et les questions resteront.")) { return; } console.log("Admin: Réinitialisation des améliorations..."); gameState.ownedUpgrades = []; gameState.unlockedCategories = ['basic', 'clicking']; gameState.factoryProgress = 0; gameState.factoryLevel = 0; gameState.critChance = 0; gameState.critMultiplier = 1.5; gameState.comboCount = 0; gameState.comboTimer = 0; gameState.globalMultiplierBPC = 1.0; gameState.globalMultiplierBPS = 1.0; gameState.currentClickableImageTier = 'default'; gameState.marketUnlocked = false; gameState.cash = 0; gameState.bonePrice = 1.0; gameState.priceHistory = []; gameState.activeEventId = null; gameState.activeEventEndTime = 0; gameState.temporaryMultipliers = { BPS: 1.0, BPC: 1.0, bonePrice: 1.0 }; gameState.lastEventTriggerTime = 0; gameState.achievements = {}; recalculateStats(); updateDisplays(); renderUpgrades(); renderMilestones(); initFactoryGrid(); updateClickableImageDisplay(); updateEventDisplay(); boneMarketSection.style.display = 'none'; if (priceChartInstance) { priceChartInstance.data.datasets[0].data = []; priceChartInstance.update('none'); } showNotification("Admin: Améliorations réinitialisées !", "fas fa-undo"); saveGame(); }

       // --- Random Event Functions ---
       function triggerRandomEvent() { if (gameState.activeEventId !== null || Date.now() - gameState.lastEventTriggerTime < MIN_TIME_BETWEEN_EVENTS) { return; } const totalWeight = randomEvents.reduce((sum, event) => sum + event.weight, 0); let randomRoll = Math.random() * totalWeight; let selectedEvent = null; for (const event of randomEvents) { if (randomRoll < event.weight) { selectedEvent = event; break; } randomRoll -= event.weight; } if (selectedEvent) { console.log("Déclenchement Événement:", selectedEvent.name); gameState.activeEventId = selectedEvent.id; gameState.activeEventEndTime = Date.now() + selectedEvent.duration * 1000; gameState.lastEventTriggerTime = Date.now(); gameState.temporaryMultipliers = { BPS: 1.0, BPC: 1.0, bonePrice: 1.0 }; if (selectedEvent.effect.tempMultiplierBPS) gameState.temporaryMultipliers.BPS = selectedEvent.effect.tempMultiplierBPS; if (selectedEvent.effect.tempMultiplierBPC) gameState.temporaryMultipliers.BPC = selectedEvent.effect.tempMultiplierBPC; if (selectedEvent.effect.tempBonePriceMultiplier) gameState.temporaryMultipliers.bonePrice = selectedEvent.effect.tempBonePriceMultiplier; showNotification(`${selectedEvent.name}: ${selectedEvent.description}`, selectedEvent.notificationIcon); updateDisplays(); if (gameState.marketUnlocked) updateMarketDisplay(); updateEventDisplay(); } }
       function checkActiveEventEnd() { if (gameState.activeEventId !== null && Date.now() >= gameState.activeEventEndTime) { const endedEvent = randomEvents.find(e => e.id === gameState.activeEventId); console.log("Fin Événement:", endedEvent ? endedEvent.name : gameState.activeEventId); showNotification(`Fin Événement: ${endedEvent ? endedEvent.name : 'Effet'} terminé`, 'fas fa-clock'); gameState.activeEventId = null; gameState.activeEventEndTime = 0; gameState.temporaryMultipliers = { BPS: 1.0, BPC: 1.0, bonePrice: 1.0 }; updateDisplays(); if (gameState.marketUnlocked) updateMarketDisplay(); updateEventDisplay(); } }
       function updateEventDisplay() { if (!eventDisplay) return; if (gameState.activeEventId) { const activeEvent = randomEvents.find(e => e.id === gameState.activeEventId); if (activeEvent) { const timeRemaining = Math.max(0, (gameState.activeEventEndTime - Date.now()) / 1000); eventDisplay.innerHTML = ` <strong>${activeEvent.name}</strong> <span>${activeEvent.description} (${formatTime(timeRemaining)} restantes)</span> `; eventDisplay.className = activeEvent.isNegative ? 'negative' : 'positive'; eventDisplay.style.display = 'block'; } else { eventDisplay.style.display = 'none'; eventDisplay.innerHTML = ''; } } else { eventDisplay.style.display = 'none'; eventDisplay.innerHTML = ''; } }

       // --- Game Initialization ---
       window.addEventListener('DOMContentLoaded', (event) => {
            console.log('DOM chargé et parsé');
            initGame();
       });
   </script>
</body>
</html>
